from django.http import StreamingHttpResponse, JsonResponse
from django.shortcuts import render, HttpResponse
import numpy as np
import cv2
from django.shortcuts import render
import os

#face_xml = 'haarcascades/haarcascade_frontalface_default.xml'
#eye_xml = 'haarcascades/haarcascade_eye.xml'
def main(request):
    return render(request,"main.html")

def faceDetect(request): #미사용
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


    face_xml = os.path.join(\
    BASE_DIR, 'face_detection/haarcascades/haarcascade_frontalface_default.xml')
    eye_xml = os.path.join(\
    BASE_DIR, 'face_detection/haarcascades/haarcascade_eye.xml')

    font = cv2.FONT_ITALIC

    eye_detect = False
    face_cascade = cv2.CascadeClassifier(face_xml)
    eye_cascade = cv2.CascadeClassifier(eye_xml)
    if face_cascade.empty():
        print("Error loading face cascade file")


    if eye_cascade.empty():
        print("Error loading eye cascade file")

    try:
        capture = cv2.VideoCapture(0)  # 노트북 웹캠 카메라
        capture.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        capture.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
    except:
        print('camera loading error')
        return render(request, 'error.html')

    while(True):
        ret, frame = capture.read()
        if not ret:
            break

        if eye_detect:
            info = 'Eye Detection ON'
        else:
            info = 'Eye Detection OFF'

        frame = cv2.flip(frame, 1)  # 좌우대칭
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        faces = face_cascade.detectMultiScale(gray, 1.3, 5)  # 1.05, 5 ?
        print('Numbers of faces detected: ' + str(len(faces)))

        # 카메라 영상 왼쪽 위에 셋팅된 info의 내용 출력
        cv2.putText(frame, info, (5, 15), font, 0.5, (255, 0, 255), 1)

        if len(faces):
            for (x, y, w, h) in faces:
                cv2.rectangle(frame, (int(x), int(y)), (int(x+w),
                              int(y+h)), (255, 0, 0), 2)  # 사각형 범위
                cv2.putText(frame, 'Detected Face', (x-5, y-5),
                            font, 0.5, (255, 255, 0), 2)  # 얼굴 찾았다는 메세지
                if eye_detect:  # 눈 찾기
                    roi_gray = gray[y:y+h, x:x+w]
                    roi_color = frame[y:y+h, x:x+w]
                    eyes = eye_cascade.detectMultiScale(roi_gray)
                    for (ex, ey, ew, eh) in eyes:
                        cv2.rectangle(roi_color, (ex, ey),
                                      (ex+ew, ey+eh), (0, 255, 0), 2)

            # 이미지 프레임을 byte 형식으로 변환
            _, jpeg = cv2.imencode('.jpg', frame)
            data = []
            data.append(jpeg.tobytes())

            return render(request, 'face_detection.html', {'data': data})

            
def camera_stream(request):
    capture = cv2.VideoCapture(0)

    while True:
        ret, frame = capture.read()
        # frame 처리 코드 ...

        _, jpeg = cv2.imencode('.jpg', frame)
        frame_bytes = jpeg.tobytes()

        
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')

        #return render(request, 'camera_stream.html', {'frame': frame_bytes})

def eye_info(request):
    if request.method == "POST":
        left_eye = request.POST.get("left_eye")
        right_eye = request.POST.get("right_eye")
        print(left_eye,right_eye)
        return JsonResponse({"success": True})
    else:
        return JsonResponse({"success": False})


def gen_frames(): #사용안함
    # 카메라에서 영상을 받아오는 함수
    cap = cv2.VideoCapture(0)
    while True:
        success, frame = cap.read()
        if not success:
            break
        else:
            # 얼굴과 눈 인식하는 코드
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            faces = face_cascade.detectMultiScale(gray, 1.3, 5)
            for (x, y, w, h) in faces:
                cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)
            eyes = eye_cascade.detectMultiScale(gray, 1.1, 3)
            for (ex, ey, ew, eh) in eyes:
                cv2.rectangle(frame, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 2)
            # 영상 프레임을 바이너리 형태로 변환해서 반환
            ret, buffer = cv2.imencode('.jpg', frame)
            frame = buffer.tobytes()
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
    cap.release()


def video_feed(request):
    return StreamingHttpResponse(camera_stream(request),
                                 content_type='multipart/x-mixed-replace; boundary=frame')
